# SYN 超时重传问题
SYN 数据包是一个很小的 TCP 数据包，用于 TCP 三次握手建立连接的第一次握手，SYN 超时重传问题是第一次握手 SYN 报文丢失或第二次握手 SYN+ACK 报文丢失
## 第一次握手 SYN 丢失
当客户端发起第一次握手，即发送 SYN 报文后，进入 **SYN_SENT** 状态，但服务器未启动或宕机，没有收到客户端的 SYN 数据包，客户端也因此无法收到服务器发来的 SYN+ACK，便会客户端超时触发重传机制，重传次数由操作系统内核决定，在 Linux 系统中，由内核的 **tcp_syn_retries** 参数控制，可自定义，一般默认为 5，五次重传时间间隔为1，2，4，8，16，当 5 次重传后，再等 32 s，若仍未收到回复，则不再重传，总耗时：1+2+4+8+16+32=63s。但由于是客户端，此代价往往可以忽略。
## 第二次握手 SYN+ACK 丢失
当服务器收到客户端的第一次握手后，即进入 **SYN_RCVD** 半连接状态，并向客户端回复 SYN+ACK 报文，若由于客户端关机等原因，导致此报文无法达到客户端，服务器也就无法收到ACK报文，此时便会触发服务器的超时重传机制，重传次数由操作系统内核决定，在 Linux 系统中，由内核的 **tcp_synack_retries** 参数控制，可自定义，一般默认为 5，五次重传时间间隔为 1，2，4，8，16，当 5 次重传后，再等 32 s，若仍未收到回复，则不再重传，总耗时：1+2+4+8+16+32=63s。但由于是服务器，往往会有大量用户连接，若都出现此问题，大量占用服务器的半连接队列数量，会使得其他人无法正常连接服务器。


## 引发的安全问题——SYN 泛洪攻击
### SYN 泛洪攻击
SYN 洪泛攻击属于典型的 DOS 攻击。攻击者利用 TCP 三次握手的漏洞，伪造大量的源地址向服务器发起三次握手，但由于源地址是伪造的，当服务器收到 SYN 数据包后，进入半连接状态，服务器回复的 SYN+ACK 数据无法到达客户端，也就无法收到客户端回复的 ACK 数据包，陷入超时重传，直到达到重传上限断开连接，由于这个过程持续长达 63s，攻击者可以使得服务器建立大量的半连接状态，耗尽其 CPU 和内存，进而使得服务器无法正常提供服务。

**SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上 SYN 攻击并不管目标是什么系统，只要这些系统打开 TCP 服务就可以实施**
### 应对方案
**SYN cookies：** 服务器收到 SYN 报文后，根据<源 IP，目的 IP，源端口，目的端口> hash 出序列号，并利用该序列号回复客户端，不进行任何资源的分配。当收到 ACK 报文后，再次利用<源 IP，目的 IP，源端口，目的端口> 进行 hash，并判断得到的 hash 值 +1 是否等于 ACK 报文中的确认值，若是，则建立连接。如果客户端没有返回 ACK 报文，则说明之前的 SYN 报文属于进行 SYN 洪泛攻击的攻击者，但由于服务器没有为它分配任何资源，故对服务器没有造成危害。